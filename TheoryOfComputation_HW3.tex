\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[margin=3cm]{geometry}
\usepackage{paralist}
\usepackage{amsthm, amsmath, amsfonts, amssymb}
\usepackage{mathtools} % \mathclap
\usepackage{bm}
\usepackage{dsfont}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{multirow}
\usepackage{comment}
\usepackage{xcolor, colortbl}
\usepackage{xifthen, xspace}
\usepackage{caption, subcaption}
\usepackage{lscape}
\usepackage{braket}
\usepackage{epigraph}
\usepackage{sectsty}
\usepackage{listings}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=blue,
    pdftitle={Overleaf Example},
    pdfpagemode=FullScreen,
    }

\title{Теоретические модели вычислений \\
ДЗ №3: Машины Тьюринга и квантовые вычисления}
\author{Рамазанов Никита, А-13а-19}
\date{1 июня 2022}

\begin{document}

\maketitle


\section{Машины Тьюринга}

\subsection{Операции с числами}

Реализуйте машины Тьюринга, которые позволяют выполнять следующие операции:
\begin{enumerate}
    \item Сложение двух унарных чисел (1 балл).\\
    Алгоритм:\\
    -- Ищем знак + и заменяем его на | (элемент унарной системы счисления);\\
    -- Сдвигаем головку в конец унарного числа;\\
    -- Удаляем последний элемент числа.
    
    Реализация - папка Task1\_1, файл `Subtask1.yml`.
    
    \item Умножение унарных чисел (1 балл).\\
    Алгоритм: \\
    -- Берем начало первого числа (первый знак |);\\
    -- Удаляем его, идем в конец второго, после него указываем разделительный знак (в нашем случае - *);\\
    -- Полностью копируем второй множитель;\\
    -- Возвращаемся в начало и проделываем то же самое для оставшихся цифр в числе;\\
    -- В конце алгоритма все, что осталось до разделительного символа, в том числе сам этот символ, удаляется.
    
    Реализация - папка Task1\_1, файл `Subtask2.yml`.
    
\end{enumerate}


\subsection{Операции с языками и символами}

Реализуйте машины Тьюринга, которые позволяют выполнять следующие операции:
\begin{enumerate}
    \item Принадлежность к языку $L = \{ 0^n1^n2^n \}, n \ge 0$ (0.5 балла)\\
    Алгоритм: \\
    -- Ищем в слове последние "0", "1" и "2"\, и заменяем их на "N";\\
    -- Повторяем, пока на ленте не останется цифр;\\
    -- Если встречаем элемент, отличный от "N"\,, то очищаем ленту и пишем "N"\, - то есть слово не принадлежит языку, иначе - очищаем и пишем "Y"\, - это означает, что слово принадлежит языку.
    
    Реализация - папка Task1\_2, файл `Subtask1.yml`.
    
    \item Проверка соблюдения правильности скобок в строке (минимум 3 вида скобок) (0.5 балла).\\
    Алгоритм: \\
    -- Ищем первую закрывающую скобку, заменяем ее на "N";\\
    -- Возвращаемся на один шаг назад - здесь должна быть открывающая скобка такого же вида, иначе - ошибка, и заменяем ее на "N";\\
    -- Идем в начало и повторяем алгоритм: сначала первая закрывающая, затем последняя открывающая перед рядом символов "N";\\
    -- Если на каком-то этапе ошибка - очищаем ленту и записываем "N" - то есть скобочная последовательность не является правильной.\\
    -- Если слева от "N" - пустой символ, то очищаем все символы "N" до первого символа, отличного от "N", если этот символ - тоже пустой, то скобочная последовательность правильная - записываем "Y".
    
    Реализация - папка Task1\_2, файл `Subtask2.yml`.
    
    \item Поиск минимального по длине слова в строке (слова состоят из символов 1 и 0 и разделены пробелом) (1 балл).\\
    Чтобы отличить пробел и пустой символ, будем считать пробелом знак \_.\\
    Алгоритм: \\
    -- Будем заменять 1 на "a"\,, 0 на "b" - сначала первый символ каждого слова, затем второй, и так далее;\\
    -- Если на каком-то шаге справа будет пустой символ, это означает, что минимальное слово найдено - ставим справа от него знак *.
    -- Удаляем все что справа, возвращаемся и удаляем все, что слева.
    
    Реализация - папка Task1\_2, файл `Subtask3.yml`.
\end{enumerate}


\section{Квантовые вычисления}


\subsection{Генерация суперпозиций 1 (1 балл)}

Дано $N$ кубитов ($1 \le N \le 8$) в нулевом состоянии $\Ket{0\dots0}$. Также дана некоторая последовательность битов, которое задаёт ненулевое базисное состояние размера $N$. Задача получить суперпозицию нулевого состояния и заданного.

$$\Ket{S} = \frac{1}{\sqrt2}(\Ket{0\dots0} +\Ket{\psi})$$

То есть требуется реализовать операцию, которая принимает на вход:

\begin{enumerate}
    \item Массив кубитов $q_s$
    \item Массив битов $bits$ описывающих некоторое состояние $\Ket{\psi}$. Это массив имеет тот же самый размер, что и $qs$. Первый элемент этого массива равен $1$.
\end{enumerate}
Решение:
\begin{lstlisting}
namespace Solution {
    open Microsoft.Quantum.Primitive;
    open Microsoft.Quantum.Canon;
    operation Solve(qs: Qubit[], bits: Bool[]) : () {
        body { 
            H(qs[0]);
            for (i in 1..Length(qs) - 1) {
                if (bits[i]) {
                    CNOT(qs[0], qs[i]); 
                } 
            }                  
        }
    }
}
\end{lstlisting}


\subsection{Различение состояний 1 (1 балл)}

Дано $N$ кубитов ($1 \le N \le 8$), которые могут быть в одном из двух состояний:

$$\Ket{GHZ} = \frac{1}{\sqrt2}(\Ket{0\dots0} +\Ket{1\dots1})$$
$$\Ket{W} = \frac{1}{\sqrt N}(\Ket{10\dots00}+\Ket{01\dots00} + \dots +\Ket{00\dots01})$$

Требуется выполнить необходимые преобразования, чтобы точно различить эти два состояния. Возвращать $0$, если первое состояние и 1, если второе. 
\\\\
Решение:
\begin{lstlisting}
namespace Solution {
    open Microsoft.Quantum.Primitive;
    open Microsoft.Quantum.Canon;
    operation Solve(qs: Qubit[]) : Int {
        body {   
            mutable one = 0;
            for (q in qs) {
                if (M(q) == One) { 
                    set one = one + 1; 
                }
            }
            if (one == 1) {
                return 1;
            } else {
                return 0;
            }                
        }
    }
}
\end{lstlisting}


\subsection{Различение состояний 2 (2 балла)}

Дано $2$ кубита, которые могут быть в одном из двух состояний:

$$\Ket{S_0} = \frac{1}{2}(\Ket{00} + \Ket{01} + \Ket{10} + \Ket{11})$$
$$\Ket{S_1} = \frac{1}{2}(\Ket{00} - \Ket{01} + \Ket{10} - \Ket{11})$$
$$\Ket{S_2} = \frac{1}{2}(\Ket{00} + \Ket{01} - \Ket{10} - \Ket{11})$$
$$\Ket{S_3} = \frac{1}{2}(\Ket{00} - \Ket{01} - \Ket{10} + \Ket{11})$$


Требуется выполнить необходимые преобразования, чтобы точно различить эти четыре состояния. Возвращать требуется индекс состояния (от $0$ до $3$). 
\\\\
Решение:
\begin{lstlisting}
namespace Solution {
    open Microsoft.Quantum.Primitive;
    open Microsoft.Quantum.Canon;
    operation Solve (qs : Qubit[]) : Int {
        body {
            H(qs[0]);
            H(qs[1]);
            if (M(qs[0]) == Zero) {
                if (M(qs[1]) == Zero) {
                    return 0;
                }
                else {
                    return 1;
                }
            }
            else {
                if (M(qs[1]) == Zero) {
                    return 2;
                }
                else {
                    return 3;
                }
            }
        }
    }
}
\end{lstlisting}

\end{document}